#!/usr/bin/env bash
#
#    ucaresystem - All-in-one system update and maintenance tool
#    Copyright:
#       2009 Salih Emin <salih@utappia.org>
#       2020 Ioannis Tsagatakis <tsagatakis@protonmail.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

set -eu
## Ensure this file can only be sourced once
base_loaded=${base_loaded:-}
if [[ "${FUNCNAME[0]}" != source ]]; then
  echo "This file can only be source"
  exit 1
fi
if [[ -n ${base_loaded} ]]; then
  echo "Warning: This file can only be sourced once"
  return 1
fi
base_loaded=true

#
# Display a header text
#
function header_text() {
  echo -e "${GREEN}${BOLD}***${BOLDOFF} ${1}${NORMAL}"
}

#
# Ask for yes/no (localized)
# Usage ask_yesno prompt res variable
#
function ask_yesno() {
  local prompt=${1:-}
  local -n _ret=${2:-}
  local response=""

  while [[ -z $response ]]; do
    read -rp "${prompt} Yes/No? " yn
    case $yn in
      [Yy]* ) response="yes" ;;
      [Nn]* ) response="no"  ;;
      *) echo "Again: ${prompt} Yes/No?" ;;
    esac
  done

  _ret="$response"
}

#
# Check if reboot is required
#
function check_reboot() {
  header_text "Checking to see if a reboot is required "
  ## Check to see if a reboot is required
  if [ -f /var/run/reboot-required ]; then
    echo
    echo "${BOLD}${RED}* * * * * * * * * * * * * * * * * *"
    echo "*                                 *"
    echo "* Consider rebooting your system  *"
    echo "* to finish applying updates      *"
    echo "*                                 *"
    echo "* * * * * * * * * * * * * * * * * *${BOLDOFF}${NORMAL}"
    echo
  fi

  if [ "$AUTO_REBOOT" == "true" ]; then
    header_text "Rebooting system"
    echo " $(basename "${0}") will reboot the system in ${AUTO_REBOOT_TIMEOUT} seconds... "
    sleep "${AUTO_REBOOT_TIMEOUT}"
    ${REBOOT}
  fi
}

#
# Check if you can sudo
#
function check_root_priv() {
  # Checking if the user has run the script with "sudo" or not
  if [[ $EUID -ne 0 ]]; then
    echo "${RED}${BOLD}Error: ${BOLDOFF} Application needs admin access.${BOLDOFF}" 1>&2
    echo "Please run the application as admin (using 'sudo' or 'su')" 1>&2
    exit 1
  fi
}

#
# Test if a program is executable by you
# Usage: text_executable path res
#
function test_excutable() {
  local -n _ret=$2
  _ret="bad"
  # shellcheck disable=SC2034
  if [[ -x $1 ]]; then _ret="ok"; fi
}

#
# Set executable
# usage set_executable VAR path required|optional
#
function set_executable() {
  set +u
  var_name=$1
  default_path=$2
  required=${3:-required}

  if [[ -z ${!var_name} ]]; then
    # User have not provide a default value. Set default
    # shellcheck disable=SC2229
    IFS= read -r "$var_name" <<< "$default_path"
  fi

  if [[ $required == "required" ]]; then
    # check if path exist
    res=""
    test_excutable "${!var_name}" res
    if [[ $res == "bad" ]]; then
      echo "Bad config option '${var_name=}':  Missing executable ${!var_name}"
      exit 2
    fi
  fi
  set -u
}

#
# Load the config file safely
#
function load_config_file() {
  config_file="/etc/ucaresystem.conf"
  if [ -r $config_file ]; then
    # shellcheck disable=SC2091
    awk -F= '/^[A-Z_]*=/ {printf "declare -g %s=%s\n", $1, $2}' $config_file
  fi

  # Configuration variables and default values
  WAIT_ACTION=${WAIT_ACTION:=0}
  KEEP_KERNELS=${KEEP_KERNELS:=2}
  DEFAULT_MODE=${DEFAULT_MODE:=maintain}
  AUTO_REBOOT=${AUTO_REBOOT:=false}
  AUTO_REBOOT_TIMEOUT=${AUTO_REBOOT_TIMEOUT:=10}
  ASK_CONFIRM=${ASK_CONFIRM:=true}
  ENABLE_TIMESHIFT=${ENABLE_TIMESHIFT:=auto}
  ENABLE_TOPGRADE=${ENABLE_TOPGRADE:=auto}

  # Programs used
  set_executable  APT_GET      /usr/bin/apt-get              required
  set_executable  DEBORPHAN    /usr/bin/deborphan            required
  set_executable  LSB_RELEASE  /usr/bin/lsb_release          required
  set_executable  REBOOT       /sbin/reboot                  required
  set_executable  SED          /bin/sed                      required
  set_executable  AWK          /usr/bin/awk                  required
  set_executable  SUDO         /usr/bin/sudo                 required
  set_executable  PS           /bin/ps                       required
  set_executable  XARGS        /usr/bin/xargs                required
  set_executable  DISTRO_INFO  /usr/bin/distro-info          required

  set_executable  UPDATE_TOOL  /usr/bin/do-release-upgrade   optional
  set_executable  TIMESHIFT    /usr/bin/timeshift            optional
  set_executable  TOPGRADE     "${HOME}/.cargo/bin/topgrade" optional
}

#
# Setup colors
#
function setup_colors() {
  RED=""
  GREEN=""
  NORMAL=""
  BOLD=""
  BOLDOFF=""

  NO_COLOR=${NO_COLOR:-}
  if [[ -z "${NO_COLOR}" ]]; then
    if test -n "$TERM" && test "$TERM" != "dumb"; then
      RED=$(tput setaf 1)
      GREEN=$(tput setaf 2)
      NORMAL=$(tput setaf 7)
      BOLD=$(tput bold)
      BOLDOFF=$(tput sgr0)
    fi
  fi
}

#
# Trap Handler
#
function trap_handler() {
  header_text "Program interrupt."
  echo "  The program have stop before finished. Your system maybe in an incomplete state."
  echo "  You may need to do:"
  echo "     sudo apt update && sudo apt install -f"
  exit 1
}

# hack for  EXEC=
function no_opp() {
  echo + "$@"
}
function yes_opp() {
  set -x
  "$@"
  { set +x; } 2>/dev/null
}

trap trap_handler 1 2 3 6
load_config_file
setup_colors